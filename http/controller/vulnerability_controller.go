package controller

import (
	"github.com/gin-gonic/gin"
	"skygo_detection/guardian/app/sys_service"
	"skygo_detection/guardian/src/net/qmap"

	"skygo_detection/lib/common_lib/http_ctx"
	"skygo_detection/lib/common_lib/mysql"
	"skygo_detection/lib/common_lib/orm"
	"skygo_detection/lib/common_lib/request"
	"skygo_detection/lib/common_lib/response"
	"skygo_detection/mongo_model"
	"skygo_detection/mysql_model"
)

type VulnerabilityController struct{}

/**
 * apiType http
 * @api {get} /api/v1/vulnerabilities 查询漏洞列表
 * @apiVersion 1.0.0
 * @apiName GetAll
 * @apiGroup Vulnerability
 *
 * @apiDescription 查询漏洞列表
 *
 * @apiUse authHeader
 *
 * @apiExample {curl} 请求示例:
 * curl -i http://localhost/api/v1/vulnerabilities
 *
 * @apiSuccessExample {json} 请求成功示例:
 * {
 *     "code": 0,
 *     "data": {
 *     }
 * }
 */
func (this VulnerabilityController) GetAll(ctx *gin.Context) {
	queryParams := ctx.Request.URL.RawQuery
	s := mysql.GetSession()

	// 查询组键
	widget := orm.PWidget{}
	widget.SetQueryStr(queryParams)
	all := widget.PaginatorFind(s, &[]mysql_model.Vulnerability{})
	response.RenderSuccess(ctx, all)
}

/**
 * apiType http
 * @api {get} /api/v1/vulnerabilities/:id 查询某一漏洞
 * @apiVersion 1.0.0
 * @apiName GetOne
 * @apiGroup Vulnerability
 *
 * @apiDescription 根据id,查询某一漏洞
 *
 * @apiUse authHeader
 *
 * @apiExample {curl} 请求示例:
 * curl -i http://localhost/api/v1/vulnerabilities/:id
 *
 * @apiSuccessExample {json} 请求成功示例:
 * {
 *     "code": 0,
 *     "data": {
 *     }
 * }
 */
func (this VulnerabilityController) GetOne(ctx *gin.Context) {
	id := request.ParamString(ctx, "id")
	s := mysql.GetSession()
	s.Where("id=?", id)

	w := orm.PWidget{}
	result, err := w.One(s, &mysql_model.Vulnerability{})

	if err == nil {
		response.RenderSuccess(ctx, result)
	} else {
		response.RenderFailure(ctx, err)
	}
}

/**
 * apiType http
 * @api {post} /api/v1/vulnerabilities 添加漏洞
 * @apiVersion 1.0.0
 * @apiName Create
 * @apiGroup Vulnerability
 *
 * @apiDescription 添加漏洞
 *
 * @apiUse authHeader
 *
 * @apiParam {int}			task_id				任务id
 * @apiParam {string}		name				漏洞名称
 * @apiParam {string}		task_case_id		任务测试用例id
 * @apiParam {int}			status				漏洞状态（0:未修复 1:已修复 2:重打开）
 * @apiParam {int}			risk_type			漏洞类型
 * @apiParam {string}		cve_id				cve id
 * @apiParam {string}		cnvd_id				cnvd id
 * @apiParam {string}		cnnvd_id			cnnvd id
 * @apiParam {int}			level				漏洞级别（ 0:提示 1:低危 2:中危 3:高危 4:严重 ）
 * @apiParam {string}		describe			漏洞描述
 * @apiParam {string}		sketch_map			漏洞示意图
 * @apiParam {string}		influence			影响范围
 * @apiParam {string}		fix_suggest			修复建议
 * @apiParam {string}		[scanner_vul_id]	漏扫的漏洞id（如果该漏洞来源于漏洞扫描报告，可以附带该字段）
 *
 * @apiParamExample {json}  请求参数示例:
 * 	{
 *		"name": "漏洞名称",
 *		"task_id":"1111",
 *		"task_case_id":"1111",
 *		"status":1,
 *		"cve_id":"1111",
 *		"risk_type":2,
 * 	}
 *
 * @apiSuccessExample {json} 请求成功示例:
 * {
 *     "code": 0
 * }
 */
func (this VulnerabilityController) Create(ctx *gin.Context) {
	info := request.GetRequestBody(ctx)
	vul := new(mysql_model.Vulnerability)
	if riskType, has := info.TryInt("risk_type"); !has {
		riskTypeName := info.MustString("risk_type_name")
		riskType = new(mongo_model.EvaluateVulType).GetVulIdTypeByName(riskTypeName)
		if riskType == 0 {
			// 如果未查询到该风险类型，则插入一个新的漏洞风险类型
			if id, err := new(mongo_model.EvaluateVulType).Upsert(qmap.QM{"name": riskTypeName}); err == nil {
				riskType = id
			} else {
				panic(err)
			}
		}
		(*info)["risk_type"] = riskType
	}

	if err := vul.Insert(*info, ctx); err == nil {
		if scannerVulId, has := info.TryString("scanner_vul_id"); has {
			// 如果该漏洞来源于漏扫报告，则将添加记录绑定到漏洞报告的这条漏洞上
			new(mysql_model.VulnerabilityScannerVulRelation).Insert(vul.TaskId, vul.TaskCaseId, vul.Id, scannerVulId)
		}
		response.RenderSuccess(ctx, nil)
	} else {
		response.RenderFailure(ctx, err)
	}
}

/**
 * apiType http
 * @api {put} /api/v1/vulnerabilities/:id 更新漏洞
 * @apiVersion 1.0.0
 * @apiName Update
 * @apiGroup Vulnerability
 *
 * @apiDescription 更新漏洞
 *
 * @apiUse authHeader
 *
 * @apiParam {string}		name			漏洞名称
 * @apiParam {string}		task_case_id	任务测试用例id
 * @apiParam {int}			status			漏洞状态（0:未修复 1:已修复 2:重打开）
 * @apiParam {int}			risk_type		漏洞类型
 * @apiParam {string}		cve_id			cve id
 * @apiParam {string}		cnvd_id			cnvd id
 * @apiParam {string}		cnnvd_id		cnnvd id
 * @apiParam {int}			level			漏洞级别（ 0:提示 1:低危 2:中危 3:高危 4:严重 ）
 * @apiParam {string}		describe		漏洞描述
 * @apiParam {string}		sketch_map		漏洞示意图
 * @apiParam {string}		influence		影响范围
 * @apiParam {string}		fix_suggest		修复建议
 *
 * @apiParamExample {json}  请求参数示例:
 * 	{
 *		"name": "漏洞名称",
 *		"task_case_id":"1111",
 *		"status":1,
 *		"cve_id":"1111",
 *		"risk_type":2,
 * 	}
 *
 * @apiSuccessExample {json} 请求成功示例:
 * {
 *     "code": 0
 * }
 */
func (this VulnerabilityController) Update(ctx *gin.Context) {
	id := request.ParamInt(ctx, "id")
	if err := new(mysql_model.Vulnerability).Update(id, *request.GetRequestBody(ctx)); err != nil {
		response.RenderFailure(ctx, err)
	} else {
		response.RenderSuccess(ctx, nil)
	}
}

/**
 * apiType http
 * @api {delete} /api/v1/vulnerabilities 删除漏洞
 * @apiVersion 1.0.0
 * @apiName BulkDelete
 * @apiGroup Vulnerability
 *
 * @apiDescription 更新漏洞
 *
 * @apiUse authHeader
 *
 * @apiParam {[]int}		ids				漏洞id
 *
 * @apiParamExample {json}  请求参数示例:
 * 	{
 *		"ids": [1,2,3],
 * 	}
 *
 * @apiSuccessExample {json} 请求成功示例:
 * {
 *     "code": 0
 *     "data":{
 *			"number":1
 *		}
 * }
 */
func (this VulnerabilityController) BulkDelete(ctx *gin.Context) {
	req := request.GetRequestBody(ctx)
	if _, has := req.TrySlice("ids"); has {
		ids := req.SliceInt("ids")
		if effectNum, err := sys_service.NewSession().DeleteByIds(new(mysql_model.Vulnerability), ids); err == nil {
			// 删除任务关联的漏洞扫描报告中的漏洞关系
			for _, id := range ids {
				new(mysql_model.VulnerabilityScannerVulRelation).Delete(0, 0, id)
			}
			response.RenderSuccess(ctx, qmap.QM{"number": effectNum})
		} else {
			response.RenderFailure(ctx, err)
		}
	}
}

func (this VulnerabilityController) AddTag(ctx *gin.Context) {
	info := request.GetRequestBody(ctx)
	vul := new(mysql_model.Vulnerability)
	if err := vul.AddTag(*info); err == nil {
		response.RenderSuccess(ctx, nil)
	} else {
		response.RenderFailure(ctx, err)
	}
}

func (this VulnerabilityController) GetAdd(ctx *gin.Context) {
	taskId := request.QueryInt(ctx, "task_id")
	vul := new(mysql_model.Vulnerability)
	result := vul.GetTag(taskId)
	response.RenderSuccess(ctx, result)
}

/**
 * apiType http
 * @api {get} /api/v1/vulnerability_logs 分页查询漏洞日志
 * @apiVersion 0.1.0
 * @apiName GetLogAll
 * @apiGroup Vulnerability
 *
 * @apiDescription 分页查询漏洞日志
 *
 * @apiUse authHeader
 *
 * @apiSuccessExample {json} 请求成功示例:
 * {
 *     "code": 0,
 *     "data": {
 *         "list": [
 *             {
 *                 "id": 5,
 *                 "level": 1,
 *                 "message": "",
 *                 "status": 2,
 *                 "task_id": 13,
 *                 "task_name": "12asdfadf1",
 *                 "user_id": 0,
 *                 "user_name": "任务监控服务"
 *				   "create_time": 1636013380,
 *				   "piece_id": 1636013380,
 *				   "piece_name": 1636013380,
 *				   "piece_version_id": 1636013380,
 *				   "piece_version_name": 1636013380,
 *             }
 *         ],
 *         "pagination": {
 *             "current_page": 1,
 *             "per_page": 20,
 *             "total": 5,
 *             "total_pages": 1
 *         }
 *     },
 *     "msg": ""
 * }
 */
func (this VulnerabilityController) GetLogAll(ctx *gin.Context) {
	queryParams := ctx.Request.URL.RawQuery
	s := mysql.GetSession()
	s.Where("user_id=?", http_ctx.GetUserId(ctx))
	widget := orm.PWidget{}
	widget.SetQueryStr(queryParams)
	widget.AddSorter(*(orm.NewSorter("id", 1)))
	all := widget.PaginatorFind(s, &[]mysql_model.VulnerabilityLog{})
	response.RenderSuccess(ctx, all)
}
