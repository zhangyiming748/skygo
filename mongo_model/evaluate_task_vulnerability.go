package mongo_model

import (
	"encoding/json"
	"time"

	"github.com/globalsign/mgo/bson"
	"skygo_detection/guardian/src/net/qmap"

	"skygo_detection/common"
	"skygo_detection/lib/common_lib/mongo"
	"skygo_detection/lib/common_lib/orm_mongo"
)

type EvaluateTaskVulnerability struct {
	Id                      bson.ObjectId                   `bson:"_id,omitempty" json:"_id"`
	VulId                   string                          `bson:"vul_id" json:"vul_id"`                                       // 漏洞id
	EvaluateTaskId          string                          `bson:"evaluate_task_id" json:"evaluate_task_id"`                   // 项目任务id
	ProjectId               string                          `bson:"project_id" json:"project_id"`                               // 项目id
	Name                    string                          `bson:"name" json:"name"`                                           // 漏洞名称
	AssetId                 string                          `bson:"asset_id" json:"asset_id"`                                   // 资产id
	AssetVersion            string                          `bson:"asset_version" json:"asset_version"`                         // 资产版本
	ItemId                  string                          `bson:"item_id" json:"item_id"`                                     // 测试用例id
	RecordId                string                          `bson:"record_id" json:"record_id"`                                 // 测试记录id
	TestPhase               int                             `bson:"test_phase" json:"test_phase"`                               // 测试阶段（1:初测、2:复测1、3:复测2、4:复测3 ...）
	Status                  int                             `bson:"status" json:"status"`                                       // 漏洞状态（0:未修复 1:已修复 2:重打开）
	CheckStatus             int                             `bson:"check_status" json:"check_status"`                           // 漏洞确认状态（0:未确认 1:已确认）
	Level                   int                             `bson:"level"  json:"level"`                                        // 漏洞级别（ 0:提示 1:低危 2:中危 3:高危 4:严重 ）
	RiskType                int                             `bson:"risk_type" json:"risk_type"`                                 // 漏洞类型
	Describe                string                          `bson:"describe" json:"describe"`                                   // 漏洞描述
	Influence               string                          `bson:"influence" json:"influence"`                                 // 影响范围
	SketchMap               interface{}                     `bson:"sketch_map" json:"sketch_map"`                               // 漏洞示意图
	Suggest                 []*EvaluateTaskVulRepairSuggest `bson:"suggest" json:"suggest"`                                     // 修复建议
	OpId                    int                             `bson:"op_id" json:"op_id"`                                         // 操作人id
	LastUpdateOpId          int                             `bson:"last_update_op_id" json:"last_update_op_id"`                 // 最后更新人id
	Tag                     []string                        `bson:"tag" json:"tag"`                                             // 漏洞标签
	CreateTime              int64                           `bson:"create_time" json:"create_time"`                             // 创建时间
	EvaluateVulnerabilityId string                          `bson:"evaluate_vulnerability_id" json:"evaluate_vulnerability_id"` // 主漏洞ID，生成项目漏洞ID时需要，通过它知道项目漏洞是新建还是覆盖
}

// 漏洞修复建议
type EvaluateTaskVulRepairSuggest struct {
	Caution      string `bson:"caution" json:"caution"`             // 注意事项
	RepairCost   string `bson:"repair_cost" json:"repair_cost"`     // 修复成本(极低 低 中 高 极高)
	RepairEffect string `bson:"repair_effect" json:"repair_effect"` // 修复效果(彻底 显著 基础)
	Importance   string `bson:"importance" json:"importance"`       // 重要程度(必要 推荐 可选)
}

// 加一个功能：
// 任务中可以创建任务漏洞，任务完成后，任务漏洞要汇总到项目漏洞。但是每次创建任务时会复制之前的漏洞，任务提交然后汇总到项目漏洞，项目漏洞每次会
// 经历一个删除然后重新创建的过程，需要保证他们的id是唯一的，这样可以基于这个唯一的项目漏洞记录，进行额外的log记录。
// 在创建任务漏洞的时候，提供一个主任务漏洞ID【master_id】，这个字段用于创建EvaluateVulnerability用的
func (this *EvaluateTaskVulnerability) Create(rawInfo qmap.QM, opId int64) (*EvaluateTaskVulnerability, error) {
	testId := rawInfo.MustString("test_id")
	taskItem, err := new(EvaluateTaskItem).GetOne(testId)
	if err != nil {
		return nil, err
	}
	itemInfo, err := new(EvaluateItem).GetOne(taskItem.ItemId)
	if err != nil {
		return nil, err
	}
	this.Id = bson.NewObjectId()
	if vulId, has := rawInfo.TryString("vul_id"); has {
		this.VulId = vulId
	} else {
		this.VulId = bson.NewObjectId().Hex()
	}

	this.ProjectId = taskItem.ProjectId
	this.ItemId = taskItem.ItemId
	this.EvaluateTaskId = taskItem.EvaluateTaskId
	this.AssetId = itemInfo.AssetId
	this.AssetVersion = new(EvaluateTask).GetAssetVersion(taskItem.EvaluateTaskId, itemInfo.AssetId)
	this.RecordId = taskItem.RecordId
	this.TestPhase = taskItem.TestPhase

	this.Name = rawInfo.MustString("name")
	this.Status = rawInfo.MustInt("status")
	this.Level = rawInfo.MustInt("level")
	this.RiskType = rawInfo.Int("risk_type")
	this.Describe = rawInfo.String("describe")
	this.Influence = rawInfo.String("influence")
	if val, has := rawInfo.TryInterface("sketch_map"); has {
		this.SketchMap = val
	}

	// 添加修复建议
	suggests := []*EvaluateTaskVulRepairSuggest{}
	rawSuggests := rawInfo.MustSlice("suggest")
	for _, item := range rawSuggests {
		var suggestQM qmap.QM = item.(map[string]interface{})
		suggest := &EvaluateTaskVulRepairSuggest{
			Caution:      suggestQM.MustString("caution"),
			RepairCost:   suggestQM.String("repair_cost"),
			RepairEffect: suggestQM.String("repair_effect"),
			Importance:   suggestQM.String("importance"),
		}
		suggests = append(suggests, suggest)
	}
	this.Suggest = suggests
	this.OpId = int(opId)
	this.LastUpdateOpId = int(opId)

	// 记录创建时间，时间戳毫秒
	this.CreateTime = time.Now().UnixNano() / 1e6
	// 主项目漏洞id，用于后续逻辑
	evaluateVulnerabilityId := rawInfo.String("evaluate_vulnerability_id")
	if evaluateVulnerabilityId == "" {
		evaluateVulnerabilityId = bson.NewObjectId().Hex()
	}
	this.EvaluateVulnerabilityId = evaluateVulnerabilityId

	println("asset id", this.AssetId)
	if err := mongo.NewMgoSession(common.MC_EVALUATE_TASK_VULNERABILITY).Insert(this); err == nil {
		return this, nil
	} else {
		return nil, err
	}
}

func (this *EvaluateTaskVulnerability) Update(id string, rawInfo qmap.QM, opId int) (*EvaluateTaskVulnerability, error) {
	params := qmap.QM{
		"e_vul_id": id,
	}

	mongoClient := mongo.NewMgoSessionWithCond(common.MC_EVALUATE_TASK_VULNERABILITY, params)
	if err := mongoClient.One(&this); err == nil {
		if val, has := rawInfo.TryString("name"); has {
			this.Name = val
		}
		if val, has := rawInfo.TryInt("status"); has {
			this.Status = val
		}
		if val, has := rawInfo.TryInt("level"); has {
			this.Level = val
		}
		if val, has := rawInfo.TryInt("risk_type"); has {
			this.RiskType = val
		}
		if val, has := rawInfo.TryString("describe"); has {
			this.Describe = val
		}
		if val, has := rawInfo.TryString("influence"); has {
			this.Influence = val
		}
		if val, has := rawInfo.TryInterface("sketch_map"); has {
			this.SketchMap = val
		}
		if _, has := rawInfo.TrySlice("suggest"); has {
			suggests := []*EvaluateTaskVulRepairSuggest{}
			rawSuggests := rawInfo.MustSlice("suggest")
			for _, item := range rawSuggests {
				var suggestQM qmap.QM = item.(map[string]interface{})
				suggest := &EvaluateTaskVulRepairSuggest{
					Caution:      suggestQM.MustString("caution"),
					RepairCost:   suggestQM.String("repair_cost"),
					RepairEffect: suggestQM.String("repair_effect"),
					Importance:   suggestQM.String("importance"),
				}
				suggests = append(suggests, suggest)
			}
			this.Suggest = suggests
		}
	}
	this.LastUpdateOpId = opId
	if err := mongo.NewMgoSession(common.MC_EVALUATE_TASK_VULNERABILITY).Update(bson.M{"_id": this.Id}, this); err != nil {
		return nil, err
	} else {
		return this, nil
	}
}

func (this *EvaluateTaskVulnerability) GetOne(id string) (*qmap.QM, error) {
	params := qmap.QM{
		"e__id": bson.ObjectIdHex(id),
	}
	ormSession := mongo.NewMgoSessionWithCond(common.MC_EVALUATE_TASK_VULNERABILITY, params)
	return ormSession.GetOne()
}

func (this *EvaluateTaskVulnerability) GetItem(data qmap.QM) error {
	resulte := qmap.QM{}
	id := data["_id"].(bson.ObjectId).Hex()
	projectId := data.String("project_id")
	targetId := data.String("target_id")
	params := bson.M{
		"project_id": projectId,
		"target_id":  targetId,
		"item_vulnerability": bson.M{
			"$elemMatch": bson.M{
				"$eq": id,
			}},
	}

	mgoSession := mongo.NewMgoSession(common.MC_EVALUATE_ITEM)
	err := mgoSession.Session.Find(params).One(&resulte)
	if len(resulte) != 0 {
		if itemId := resulte["_id"]; itemId != "" {
			tmp := itemId.(bson.ObjectId).Hex()
			this.UpdateItemId(id, tmp)
		}
	}
	return err
}

func (this *EvaluateTaskVulnerability) UpdateItemId(id, itemId string) error {
	selector := bson.M{
		"_id": bson.ObjectIdHex(id),
	}
	update := bson.M{
		"$set": bson.M{
			"item_id": itemId,
		},
	}
	if err := mongo.NewMgoSession(common.MC_EVALUATE_TASK_VULNERABILITY).Update(selector, &update); err != nil {
		return err
	} else {
		return nil
	}
}

// 根据漏洞的id 删除漏洞
func (this *EvaluateTaskVulnerability) BulkDelete(rawIds []string) (*qmap.QM, error) {
	effectNum := 0
	ids := []bson.ObjectId{}
	for _, id := range rawIds {
		ids = append(ids, bson.ObjectIdHex(id))
	}
	if len(ids) > 0 {
		match := bson.M{
			"_id": bson.M{"$in": ids},
		}
		if changeInfo, err := mongo.NewMgoSession(common.MC_EVALUATE_TASK_VULNERABILITY).RemoveAll(match); err == nil {
			effectNum = changeInfo.Removed
		} else {
			return nil, err
		}
	}
	return &qmap.QM{"number": effectNum}, nil
}

// 根据item id 删除漏洞
func (this *EvaluateTaskVulnerability) BulkDeleteByItemIds(itemIds []string) (*qmap.QM, error) {
	effectNum := 0
	if len(itemIds) > 0 {
		match := bson.M{
			"item_id": bson.M{"$in": itemIds},
		}
		if changeInfo, err := mongo.NewMgoSession(common.MC_EVALUATE_TASK_VULNERABILITY).RemoveAll(match); err == nil {
			effectNum = changeInfo.Removed
		} else {
			return nil, err
		}
	}
	return &qmap.QM{"number": effectNum}, nil
}

// 根据target_id 删除漏洞
func (this *EvaluateTaskVulnerability) BulkDeleteByTargetIds(targetIds []string) (*qmap.QM, error) {
	effectNum := 0
	if len(targetIds) > 0 {
		match := bson.M{
			"target_id": bson.M{"$in": targetIds},
		}
		if changeInfo, err := mongo.NewMgoSession(common.MC_EVALUATE_TASK_VULNERABILITY).RemoveAll(match); err == nil {
			effectNum = changeInfo.Removed
		} else {
			return nil, err
		}
	}
	return &qmap.QM{"number": effectNum}, nil
}

// 查询测试用例关联的任务下的漏洞列表
func (this *EvaluateTaskVulnerability) GetItemTaskVuls(evaluateTaskId, itemId string) ([]map[string]interface{}, error) {
	params := qmap.QM{
		"e_item_id":          itemId,
		"e_evaluate_task_id": evaluateTaskId,
	}
	return orm_mongo.NewWidgetWithParams(common.MC_EVALUATE_TASK_VULNERABILITY, params).Find()
}

// 查询测试用例关联已存在的漏洞
func (this *EvaluateTaskVulnerability) GetItemVuls(itemId string) ([]EvaluateVulnerability, error) {
	params := bson.M{
		"item_id": itemId,
	}
	session := mongo.NewMgoSession(common.MC_EVALUATE_VULNERABILITY)

	models := make([]EvaluateVulnerability, 0)
	err := session.Session.Find(params).All(&models)
	return models, err
}

// 复制已存在的漏洞到新的任务副本中
func (this *EvaluateTaskVulnerability) CopyItemVulsToNewTask(itemId, testId string, opId int64) error {
	if list, err := this.GetItemVuls(itemId); err == nil {
		for _, vul := range list {
			bytes, _ := json.Marshal(vul)
			data := make(map[string]interface{})
			json.Unmarshal(bytes, &data)

			data["task_item_id"] = testId
			data["test_id"] = testId
			// 复制的时候，是从主漏洞表中拿这个测试项的所有漏洞进行复制，复制的时候，标记好其主漏洞id
			data["evaluate_vulnerability_id"] = vul.Id.Hex()
			if _, err := this.Create(data, opId); err != nil {
				return err
			}
		}
	}
	return nil
}

func (this *EvaluateTaskVulnerability) One(id string) (*EvaluateTaskVulnerability, error) {
	params := qmap.QM{
		"e__id": bson.ObjectIdHex(id),
	}
	err := mongo.NewMgoSessionWithCond(common.MC_EVALUATE_TASK_VULNERABILITY, params).One(this)
	return this, err
}
