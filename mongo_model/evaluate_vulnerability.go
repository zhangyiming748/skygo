package mongo_model

import (
	"time"

	"github.com/globalsign/mgo/bson"
	"skygo_detection/guardian/src/net/qmap"

	"skygo_detection/common"
	"skygo_detection/lib/common_lib/mongo"
)

type EvaluateVulnerability struct {
	Id             bson.ObjectId               `bson:"_id,omitempty" json:"_id"`
	ProjectId      string                      `bson:"project_id" json:"project_id"`               // 项目id
	Name           string                      `bson:"name" json:"name"`                           // 漏洞名称
	EvaluateTaskId string                      `bson:"evaluate_task_id" json:"evaluate_task_id"`   // 项目任务id
	AssetId        string                      `bson:"asset_id" json:"asset_id"`                   // 资产id
	AssetVersion   string                      `bson:"asset_version" json:"asset_version"`         // 资产版本
	ItemId         string                      `bson:"item_id" json:"item_id"`                     // 测试用例id
	RecordId       string                      `bson:"record_id" json:"record_id"`                 // 测试记录id
	TestPhase      int                         `bson:"test_phase" json:"test_phase"`               // 测试阶段（1:初测、2:复测1、3:复测2、4:复测3 ...）
	Status         int                         `bson:"status" json:"status"`                       // 漏洞状态（0:未修复 1:已修复 2:重打开）
	CheckStatus    int                         `bson:"check_status" json:"check_status"`           // 漏洞确认状态（0:未确认 1:已确认）
	Level          int                         `bson:"level"  json:"level"`                        // 漏洞级别（ 0:提示 1:低危 2:中危 3:高危 4:严重 ）
	RiskType       int                         `bson:"risk_type" json:"risk_type"`                 // 漏洞类型
	Describe       string                      `bson:"describe" json:"describe"`                   // 漏洞描述
	Influence      string                      `bson:"influence" json:"influence"`                 // 影响范围
	SketchMap      interface{}                 `bson:"sketch_map" json:"sketch_map"`               // 漏洞示意图
	Suggest        []*EvaluateVulRepairSuggest `bson:"suggest" json:"suggest"`                     // 修复建议
	OpId           int                         `bson:"op_id" json:"op_id"`                         // 操作人id
	LastUpdateOpId int                         `bson:"last_update_op_id" json:"last_update_op_id"` // 最后更新人id
	Tag            []string                    `bson:"tag" json:"tag"`                             // 漏洞标签
	CreateTime     int64                       `bson:"create_time" json:"create_time"`             // 创建时间
}

// 漏洞修复建议
type EvaluateVulRepairSuggest struct {
	Caution      string `bson:"caution" json:"caution"`             // 注意事项
	RepairCost   string `bson:"repair_cost" json:"repair_cost"`     // 修复成本(极低 低 中 高 极高)
	RepairEffect string `bson:"repair_effect" json:"repair_effect"` // 修复效果(彻底 显著 基础)
	Importance   string `bson:"importance" json:"importance"`       // 重要程度(必要 推荐 可选)
}

func (this *EvaluateVulnerability) Create(rawInfo qmap.QM, opId int64) (*EvaluateVulnerability, error) {
	testId := rawInfo.MustString("test_id")
	taskItem, err := new(EvaluateTaskItem).GetOne(testId)
	if err != nil {
		return nil, err
	}
	itemInfo, err := new(EvaluateItem).GetOne(taskItem.ItemId)
	if err != nil {
		return nil, err
	}
	if Id, has := rawInfo.TryString("_id"); has {
		this.Id = bson.ObjectIdHex(Id)
	} else {
		this.Id = bson.NewObjectId()
	}

	this.ProjectId = taskItem.ProjectId
	this.ItemId = taskItem.ItemId
	this.EvaluateTaskId = taskItem.EvaluateTaskId
	this.AssetId = itemInfo.AssetId
	this.AssetVersion = new(EvaluateTask).GetAssetVersion(taskItem.EvaluateTaskId, itemInfo.AssetId)
	this.RecordId = taskItem.RecordId
	this.TestPhase = taskItem.TestPhase

	this.Name = rawInfo.MustString("name")
	this.Status = rawInfo.MustInt("status")
	this.Level = rawInfo.MustInt("level")
	this.RiskType = rawInfo.Int("risk_type")
	this.Describe = rawInfo.String("describe")
	this.Influence = rawInfo.String("influence")
	if val, has := rawInfo.TryInterface("sketch_map"); has {
		this.SketchMap = val
	}

	// 添加修复建议
	suggests := []*EvaluateVulRepairSuggest{}
	rawSuggests := rawInfo.MustSlice("suggest")
	for _, item := range rawSuggests {
		var suggestQM qmap.QM = item.(map[string]interface{})
		suggest := &EvaluateVulRepairSuggest{
			Caution:      suggestQM.MustString("caution"),
			RepairCost:   suggestQM.String("repair_cost"),
			RepairEffect: suggestQM.String("repair_effect"),
			Importance:   suggestQM.String("importance"),
		}
		suggests = append(suggests, suggest)
	}
	this.Suggest = suggests
	this.OpId = rawInfo.Int("op_id")
	this.LastUpdateOpId = rawInfo.Int("op_id")
	this.CreateTime = time.Now().UnixNano() / 1e6
	// println("asset id", this.AssetId)
	if err := mongo.NewMgoSession(common.MC_EVALUATE_VULNERABILITY).Insert(this); err == nil {
		return this, nil
	} else {
		return nil, err
	}
}

func (this *EvaluateVulnerability) Update(id string, rawInfo qmap.QM, opId int) (*EvaluateVulnerability, error) {
	params := qmap.QM{
		"e__id": bson.ObjectIdHex(id),
	}
	mongoClient := mongo.NewMgoSessionWithCond(common.MC_EVALUATE_VULNERABILITY, params)
	if err := mongoClient.One(&this); err == nil {
		if val, has := rawInfo.TryString("name"); has {
			this.Name = val
		}
		if val, has := rawInfo.TryInt("status"); has {
			this.Status = val
		}
		if val, has := rawInfo.TryInt("level"); has {
			this.Level = val
		}
		if val, has := rawInfo.TryInt("risk_type"); has {
			this.RiskType = val
		}
		if val, has := rawInfo.TryString("describe"); has {
			this.Describe = val
		}
		if val, has := rawInfo.TryString("influence"); has {
			this.Influence = val
		}
		if val, has := rawInfo.TryInterface("sketch_map"); has {
			this.SketchMap = val
		}
		if _, has := rawInfo.TrySlice("suggest"); has {
			suggests := []*EvaluateVulRepairSuggest{}
			rawSuggests := rawInfo.MustSlice("suggest")
			for _, item := range rawSuggests {
				var suggestQM qmap.QM = item.(map[string]interface{})
				suggest := &EvaluateVulRepairSuggest{
					Caution:      suggestQM.MustString("caution"),
					RepairCost:   suggestQM.String("repair_cost"),
					RepairEffect: suggestQM.String("repair_effect"),
					Importance:   suggestQM.String("importance"),
				}
				suggests = append(suggests, suggest)
			}
			this.Suggest = suggests
		}
	}
	this.LastUpdateOpId = opId
	if err := mongo.NewMgoSession(common.MC_EVALUATE_VULNERABILITY).Update(bson.M{"_id": this.Id}, this); err != nil {
		return nil, err
	} else {
		return this, nil
	}
}

func (this *EvaluateVulnerability) GetOne(id string) (*qmap.QM, error) {
	params := qmap.QM{
		"e__id": bson.ObjectIdHex(id),
	}
	ormSession := mongo.NewMgoSessionWithCond(common.MC_EVALUATE_VULNERABILITY, params)
	return ormSession.GetOne()
}

func (this *EvaluateVulnerability) GetItem(data qmap.QM) error {
	resulte := qmap.QM{}
	id := data["_id"].(bson.ObjectId).Hex()
	projectId := data.String("project_id")
	targetId := data.String("target_id")
	params := bson.M{
		"project_id": projectId,
		"target_id":  targetId,
		"item_vulnerability": bson.M{
			"$elemMatch": bson.M{
				"$eq": id,
			}},
	}

	mgoSession := mongo.NewMgoSession(common.MC_EVALUATE_ITEM)
	err := mgoSession.Session.Find(params).One(&resulte)
	if len(resulte) != 0 {
		if itemId := resulte["_id"]; itemId != "" {
			tmp := itemId.(bson.ObjectId).Hex()
			this.UpdateItemId(id, tmp)
		}
	}
	return err
}

func (this *EvaluateVulnerability) UpdateItemId(id, itemId string) error {
	selector := bson.M{
		"_id": bson.ObjectIdHex(id),
	}
	update := bson.M{
		"$set": bson.M{
			"item_id": itemId,
		},
	}
	if err := mongo.NewMgoSession(common.MC_EVALUATE_VULNERABILITY).Update(selector, &update); err != nil {
		return err
	} else {
		return nil
	}
}

// 根据漏洞的id 删除漏洞
func (this *EvaluateVulnerability) BulkDelete(rawIds []string) (*qmap.QM, error) {
	effectNum := 0
	ids := []bson.ObjectId{}
	for _, id := range rawIds {
		ids = append(ids, bson.ObjectIdHex(id))
	}
	if len(ids) > 0 {
		match := bson.M{
			"_id": bson.M{"$in": ids},
		}
		if changeInfo, err := mongo.NewMgoSession(common.MC_EVALUATE_VULNERABILITY).RemoveAll(match); err == nil {
			effectNum = changeInfo.Removed
		} else {
			return nil, err
		}
	}
	return &qmap.QM{"number": effectNum}, nil
}

// 根据item id 删除漏洞
func (this *EvaluateVulnerability) BulkDeleteByItemIds(itemIds []string) (*qmap.QM, error) {
	effectNum := 0
	if len(itemIds) > 0 {
		match := bson.M{
			"item_id": bson.M{"$in": itemIds},
		}
		if changeInfo, err := mongo.NewMgoSession(common.MC_EVALUATE_VULNERABILITY).RemoveAll(match); err == nil {
			effectNum = changeInfo.Removed
		} else {
			return nil, err
		}
	}
	return &qmap.QM{"number": effectNum}, nil
}

// 根据target_id 删除漏洞
func (this *EvaluateVulnerability) BulkDeleteByTargetIds(targetIds []string) (*qmap.QM, error) {
	effectNum := 0
	if len(targetIds) > 0 {
		match := bson.M{
			"target_id": bson.M{"$in": targetIds},
		}
		if changeInfo, err := mongo.NewMgoSession(common.MC_EVALUATE_VULNERABILITY).RemoveAll(match); err == nil {
			effectNum = changeInfo.Removed
		} else {
			return nil, err
		}
	}
	return &qmap.QM{"number": effectNum}, nil
}

// 查询测试用例关联的所有测试记录
func (this *EvaluateVulnerability) GetItemRelatedVulnerabilities(itemId string) (*[]map[string]interface{}, error) {
	params := qmap.QM{
		"e_item_id": itemId,
	}
	return mongo.NewMgoSessionWithCond(common.MC_EVALUATE_VULNERABILITY, params).Get()
}

// 统计测试用例关联的漏洞数量
func (this *EvaluateVulnerability) CountItemVuls(itemId string) int {
	if Vuls, err := this.GetItemRelatedVulnerabilities(itemId); err == nil {
		return len(*Vuls)
	}
	return 0
}

func (this *EvaluateVulnerability) One(id string) (*EvaluateVulnerability, error) {
	params := qmap.QM{
		"e__id": bson.ObjectIdHex(id),
	}
	err := mongo.NewMgoSessionWithCond(common.MC_EVALUATE_VULNERABILITY, params).One(this)
	return this, err
}

// 统计项目漏洞数量
func (this *EvaluateVulnerability) CountProjectVuls(projectIds []string) int {
	params := qmap.QM{
		"in_project_id": projectIds,
	}
	if count, err := mongo.NewMgoSessionWithCond(common.MC_EVALUATE_VULNERABILITY, params).Count(); err == nil {
		return count
	}
	return 0
}

// 统计项目资产漏洞分布情况
func (this *EvaluateVulnerability) StatisticAssetVul(projectId string) []qmap.QM {
	match := bson.M{
		"project_id": bson.M{"$eq": projectId},
	}
	group := bson.M{
		"_id":      bson.M{"asset_id": "$asset_id"},
		"asset_id": bson.M{"$first": "$asset_id"},
		"number":   bson.M{"$sum": 1},
	}
	operations := []bson.M{
		{"$match": match},
		{"$group": group},
	}
	result := []qmap.QM{}
	resp := []bson.M{}
	if err := mongo.NewMgoSession(common.MC_EVALUATE_ITEM).Session.Pipe(operations).All(&resp); err == nil {
		for _, item := range resp {
			var itemQM qmap.QM = map[string]interface{}(item)
			assetId := itemQM.String("asset_id")
			asset := qmap.QM{
				"asset_id":   assetId,
				"asset_name": new(EvaluateAsset).GetAssetName(assetId),
				"number":     itemQM.Int("number"),
			}
			result = append(result, asset)
		}
	} else {
		panic(err)
	}
	return result
}

// 统计项目漏洞修复情况
func (this *EvaluateVulnerability) StatisticProjectVulPatch(projectId string) []qmap.QM {
	match := bson.M{
		"project_id": bson.M{"$eq": projectId},
	}
	group := bson.M{
		"_id":    bson.M{"status": "$status"},
		"status": bson.M{"$first": "$status"},
		"number": bson.M{"$sum": 1},
	}
	operations := []bson.M{
		{"$match": match},
		{"$group": group},
	}
	unpatch := 0
	patched := 0
	resp := []bson.M{}
	if err := mongo.NewMgoSession(common.MC_EVALUATE_ITEM).Session.Pipe(operations).All(&resp); err == nil {
		for _, item := range resp {
			var itemQM qmap.QM = map[string]interface{}(item)
			switch itemQM.Int("status") {
			case common.VS_UNREPAIR, common.VS_REOPEN:
				unpatch += itemQM.Int("number")
			case common.VS_REPAIRED:
				patched += itemQM.Int("number")
			}
		}
	} else {
		panic(err)
	}
	result := []qmap.QM{
		{
			"name":   "已修复",
			"number": patched,
		},
		{
			"name":   "未修复",
			"number": unpatch,
		},
	}
	return result
}
